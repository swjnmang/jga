#!/usr/bin/env node

import fs from 'node:fs';
import path from 'node:path';

const playlistId = process.env.SPOTIFY_PLAYLIST_ID || process.argv[2];
const clientId = process.env.SPOTIFY_CLIENT_ID;
const clientSecret = process.env.SPOTIFY_CLIENT_SECRET;

if (!playlistId) {
  console.error('Missing playlist id. Set SPOTIFY_PLAYLIST_ID or pass as first arg.');
  process.exit(1);
}

if (!clientId || !clientSecret) {
  console.error('Missing Spotify credentials. Set SPOTIFY_CLIENT_ID and SPOTIFY_CLIENT_SECRET.');
  process.exit(1);
}

async function getToken() {
  const body = new URLSearchParams({ grant_type: 'client_credentials' });
  const auth = Buffer.from(`${clientId}:${clientSecret}`).toString('base64');
  const res = await fetch('https://accounts.spotify.com/api/token', {
    method: 'POST',
    headers: {
      Authorization: `Basic ${auth}`,
      'Content-Type': 'application/x-www-form-urlencoded',
    },
    body,
  });

  if (!res.ok) {
    const text = await res.text();
    throw new Error(`Token request failed: ${res.status} ${res.statusText} – ${text}`);
  }

  const json = await res.json();
  return json.access_token;
}

async function fetchAllTracks(token, id) {
  const items = [];
  let offset = 0;
  const limit = 100;

  for (;;) {
    const url = `https://api.spotify.com/v1/playlists/${id}/tracks?limit=${limit}&offset=${offset}`;
    const res = await fetch(url, {
      headers: { Authorization: `Bearer ${token}` },
    });

    if (!res.ok) {
      const text = await res.text();
      throw new Error(`Playlist fetch failed: ${res.status} ${res.statusText} – ${text}`);
    }

    const json = await res.json();
    const pageItems = json.items ?? [];
    items.push(...pageItems);

    if (!json.next || pageItems.length === 0) break;
    offset += pageItems.length;
  }

  return items;
}

function toYear(releaseDate) {
  if (!releaseDate) return new Date().getFullYear();
  const year = Number(String(releaseDate).slice(0, 4));
  return Number.isFinite(year) ? year : new Date().getFullYear();
}

function slugify(value) {
  return value
    .toLowerCase()
    .normalize('NFD')
    .replace(/[^a-z0-9\s-]/g, '')
    .trim()
    .replace(/\s+/g, '-')
    .replace(/-+/g, '-');
}

function toCard(item) {
  const track = item.track;
  if (!track || track.type !== 'track') return null;
  const artists = track.artists?.map((a) => a.name).filter(Boolean) ?? [];
  const artistStr = artists.join(', ') || 'Unbekannter Artist';
  const year = toYear(track.album?.release_date);
  const slug = slugify(`${track.name}-${year}`) || track.id;

  return {
    id: `song-${slug}`,
    title: track.name,
    category: 'music',
    year,
    cue: 'Song anhören und einordnen.',
    answer: `${artistStr} — ${year}, ${track.name}.`,
    hint: artistStr,
    difficulty: 'mittel',
    sources: {
      spotify: track.external_urls?.spotify,
    },
  };
}

async function main() {
  const token = await getToken();
  const rawItems = await fetchAllTracks(token, playlistId);
  const cards = rawItems
    .map((item) => toCard(item))
    .filter(Boolean)
    // dedupe by spotify url to avoid duplicates
    .reduce((acc, card) => {
      const key = card.sources.spotify;
      if (!key || acc.seen.has(key)) return acc;
      acc.seen.add(key);
      acc.list.push(card);
      return acc;
    }, { seen: new Set(), list: [] }).list;

  const outputPath = path.join(process.cwd(), 'lib', 'playlistCards.ts');
  const file = `// AUTO-GENERATED by scripts/sync-playlist.mjs\n` +
    `// Do not edit manually.\n` +
    `import { Card } from './types';\n\n` +
    `export const playlistCards: Card[] = ${JSON.stringify(cards, null, 2)};\n`;

  fs.writeFileSync(outputPath, file);
  console.log(`Wrote ${cards.length} cards to ${path.relative(process.cwd(), outputPath)}`);
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
